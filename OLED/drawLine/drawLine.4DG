#platform "GOLDELOX"

/*
 * Spencer Barton, March 2014
 * Test: Draw a line on the uTOLED-20-G2
 */

#inherit "4DGL_16bitColours.fnc"

// define a custom font.
// Custom fonts can also be placed in MEDIA (ie on uSD card), however
// text blitting will run much faster from a data statement.
#DATA
    byte MS_SanSerif8x12
    2,                                                          // Type 2, Char Width preceeds character; Table of widths also
    96,                                                         // Num chars
    32,                                                         // Starting Char
    8,                                                          // Font_Width
    12,                                                         // Font_Height
    4, 4, 6, 8, 7, 8, 7, 3,                                     // Widths of chars 0x32 to 0x39
    4, 4, 5, 7, 4, 4, 4, 6,                                     // etc.
    7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 4, 4, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 7, 8,
    8, 4, 6, 8, 7, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 4, 6, 4, 7, 7,
    4, 7, 7, 7, 7, 7, 4, 7,
    7, 3, 3, 7, 3, 9, 7, 7,
    7, 7, 4, 6, 4, 7, 7, 8,
    6, 6, 6, 5, 3, 5, 8, 4,
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 32 ' '
    4, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x40, 0x00,   // 33 '!'
    6, 0x00, 0x00, 0x48, 0x48, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 34 '"'
    8, 0x00, 0x00, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x00,   // 35 '#'
    7, 0x00, 0x00, 0x10, 0x38, 0x54, 0x50, 0x30, 0x18, 0x14, 0x54, 0x38, 0x10,   // 36 '$'
    8, 0x00, 0x00, 0x30, 0x49, 0x32, 0x04, 0x08, 0x10, 0x26, 0x49, 0x06, 0x00,   // 37 '%'
    7, 0x00, 0x00, 0x20, 0x50, 0x50, 0x20, 0x20, 0x54, 0x48, 0x48, 0x34, 0x00,   // 38 '&'
    3, 0x00, 0x00, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 39 '''
    4, 0x00, 0x00, 0x20, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,   // 40 '('
    4, 0x00, 0x00, 0x40, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 41 ')'
    5, 0x00, 0x00, 0x00, 0x50, 0x20, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 42 '*'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00,   // 43 '+'
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40,   // 44 ','
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,   // 45 '-'
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,   // 46 '.'
    6, 0x00, 0x00, 0x08, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x00,   // 47 '/'
    7, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,   // 48 '0'
    7, 0x00, 0x00, 0x10, 0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,   // 49 '1'
    7, 0x00, 0x00, 0x38, 0x44, 0x04, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7C, 0x00,   // 50 '2'
    7, 0x00, 0x00, 0x38, 0x44, 0x04, 0x04, 0x18, 0x04, 0x04, 0x44, 0x38, 0x00,   // 51 '3'
    7, 0x00, 0x00, 0x08, 0x18, 0x18, 0x28, 0x28, 0x48, 0x7C, 0x08, 0x08, 0x00,   // 52 '4'
    7, 0x00, 0x00, 0x7C, 0x40, 0x40, 0x78, 0x44, 0x04, 0x04, 0x44, 0x38, 0x00,   // 53 '5'
    7, 0x00, 0x00, 0x38, 0x44, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x38, 0x00,   // 54 '6'
    7, 0x00, 0x00, 0x7C, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20, 0x00,   // 55 '7'
    7, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,   // 56 '8'
    7, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x3C, 0x04, 0x04, 0x44, 0x38, 0x00,   // 57 '9'
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,   // 58 ':'
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40,   // 59 ';'
    7, 0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x00,   // 60 '<'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x7C, 0x00, 0x00, 0x00,   // 61 '='
    7, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x10, 0x20, 0x40, 0x00,   // 62 '>'
    7, 0x00, 0x00, 0x38, 0x44, 0x04, 0x04, 0x08, 0x10, 0x10, 0x00, 0x10, 0x00,   // 63 '?'
    8, 0x00, 0x00, 0x0C, 0x32, 0x21, 0x4D, 0x53, 0x52, 0x4C, 0x20, 0x31, 0x0E,   // 64 '@'
    8, 0x00, 0x00, 0x10, 0x10, 0x28, 0x28, 0x44, 0x44, 0x7C, 0x82, 0x82, 0x00,   // 65 'A'
    8, 0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x78, 0x44, 0x44, 0x44, 0x78, 0x00,   // 66 'B'
    8, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00,   // 67 'C'
    8, 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00,   // 68 'D'
    8, 0x00, 0x00, 0x7C, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7C, 0x00,   // 69 'E'
    7, 0x00, 0x00, 0x7C, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x00,   // 70 'F'
    8, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x46, 0x3A, 0x00,   // 71 'G'
    8, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00,   // 72 'H'
    4, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   // 73 'I'
    6, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x90, 0x60, 0x00,   // 74 'J'
    8, 0x00, 0x00, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00,   // 75 'K'
    7, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C, 0x00,   // 76 'L'
    8, 0x00, 0x00, 0x41, 0x41, 0x63, 0x63, 0x55, 0x55, 0x49, 0x49, 0x41, 0x00,   // 77 'M'
    8, 0x00, 0x00, 0x42, 0x62, 0x62, 0x52, 0x52, 0x4A, 0x46, 0x46, 0x42, 0x00,   // 78 'N'
    8, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,   // 79 'O'
    8, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00,   // 80 'P'
    8, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4A, 0x46, 0x3C, 0x02,   // 81 'Q'
    8, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x00,   // 82 'R'
    8, 0x00, 0x00, 0x38, 0x44, 0x40, 0x40, 0x38, 0x04, 0x04, 0x44, 0x38, 0x00,   // 83 'S'
    8, 0x00, 0x00, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,   // 84 'T'
    8, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,   // 85 'U'
    8, 0x00, 0x00, 0x41, 0x41, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00,   // 86 'V'
    8, 0x00, 0x00, 0x41, 0x41, 0x41, 0x22, 0x2A, 0x2A, 0x1C, 0x14, 0x14, 0x00,   // 87 'W'
    8, 0x00, 0x00, 0x41, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x41, 0x00,   // 88 'X'
    8, 0x00, 0x00, 0x41, 0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,   // 89 'Y'
    8, 0x00, 0x00, 0x7F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7F, 0x00,   // 90 'Z'
    4, 0x00, 0x00, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,   // 91 '['
    6, 0x00, 0x00, 0x40, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x00,   // 92 '\'
    4, 0x00, 0x00, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,   // 93 ']'
    7, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 94 '^'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 95 '_'
    4, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 96 '`'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3C, 0x44, 0x44, 0x3C, 0x00,   // 97 'a'
    7, 0x00, 0x00, 0x40, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x44, 0x78, 0x00,   // 98 'b'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x40, 0x40, 0x44, 0x38, 0x00,   // 99 'c'
    7, 0x00, 0x00, 0x04, 0x04, 0x04, 0x3C, 0x44, 0x44, 0x44, 0x44, 0x3C, 0x00,   // 100 'd'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x7C, 0x40, 0x44, 0x38, 0x00,   // 101 'e'
    4, 0x00, 0x00, 0x20, 0x40, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   // 102 'f'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x44, 0x44, 0x44, 0x44, 0x3C, 0x04,   // 103 'g'
    7, 0x00, 0x00, 0x40, 0x40, 0x40, 0x58, 0x64, 0x44, 0x44, 0x44, 0x44, 0x00,   // 104 'h'
    3, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   // 105 'i'
    3, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,   // 106 'j'
    7, 0x00, 0x00, 0x40, 0x40, 0x40, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44, 0x00,   // 107 'k'
    3, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   // 108 'l'
    9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x49, 0x49, 0x00,   // 109 'm'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x64, 0x44, 0x44, 0x44, 0x44, 0x00,   // 110 'n'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,   // 111 'o'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x78, 0x40,   // 112 'p'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x44, 0x44, 0x44, 0x44, 0x3C, 0x04,   // 113 'q'
    4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00,   // 114 'r'
    6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x48, 0x20, 0x10, 0x48, 0x30, 0x00,   // 115 's'
    4, 0x00, 0x00, 0x00, 0x40, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40, 0x20, 0x00,   // 116 't'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x4C, 0x34, 0x00,   // 117 'u'
    7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x00,   // 118 'v'
    8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x49, 0x55, 0x55, 0x22, 0x22, 0x00,   // 119 'w'
    6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x48, 0x30, 0x30, 0x48, 0x48, 0x00,   // 120 'x'
    6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x48, 0x48, 0x48, 0x30, 0x20, 0x20,   // 121 'y'
    6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x08, 0x10, 0x20, 0x40, 0x78, 0x00,   // 122 'z'
    5, 0x00, 0x10, 0x20, 0x20, 0x20, 0x20, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10,   // 123 '{'
    3, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,   // 124 '|'
    5, 0x00, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x20, 0x20, 0x20, 0x20, 0x40,   // 125 '}'
    8, 0x00, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 126 '~'
    4, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60    // 127 ''
#END

// a message for the moving banner
#DATA
    byte message "......Goldelox Graphics......",0
#END


// the 'wall' colours
#CONST
    LEFTCOLOUR      0xF800
    RIGHTCOLOUR     0xFFFF
    TOPCOLOUR       0x001F
    BOTTOMCOLOUR    0x07E0
#END

// constants for the viewport
// These may need adjusting for smaller displays
#CONST
    windowXpos      30
    windowYpos      30
    windowWidth     110
    windowHeight    60
#END

// object types.
// 2,3,4,5 and 6 doubles as polygon vertices counts
#CONST
    RANDOM          0
    CIRCLE          1
    LINE            2
    TRIANGLE        3
    RECTANGLE       4
    PENTAGON        5
    HEXAGON         6
#END


// 'ball' speed factors determine
// how many pixels to jump per movement
#constant XSPEED        3
#constant YSPEED        2

// the width of the side walls
#constant WALLWIDTH     2

// 'ball' object radius
#constant BALLSIZE 4

// global working variables
var ball_x, ball_y, ball_r, ball_colour;
var xdir, ydir, xspeed, yspeed;
var screenwidth, screenheight, xc, yc;
var tophit, bottomhit, lefthit, righthit;
var windowLeft, windowTop, windowRight, windowBottom;
var angle, newseed;

// global variables for the polygon generator
var Xcoords[6], Ycoords[6];     // big enough for a hexagon
var targetX, targetY;           // targets for orbit

// array of pointers for text messages
var messages[4];


// polyline array for scope
#constant SAMPLES 20
var ScopeBufX[SAMPLES];
var ScopeBufY[SAMPLES];
var freq[4];

var mediaflag;      // set to 1 if uSD card detected

//===================================================================================
// draw random waveform
//===================================================================================
func doRandScope(var samples, var colr, var smpl)
    var w,h,n,xstep,yoffs,x,yscale,xoffs,seedoffs;
    w := windowRight-windowLeft;
    h := windowBottom-windowTop;
    xstep:=w/samples+1;
    yscale:=h/2;
    yoffs:=h/2+windowTop;
    SEED(smpl);
    x:=windowLeft;
    while (n<samples)
        // undraw the old sample as we create new one (looks better, less flicker)
        gfx_Line(ScopeBufX[n],ScopeBufY[n],ScopeBufX[n+1],ScopeBufY[n+1],BLACK);
        ScopeBufY[n]:=(RAND()%yscale)+yoffs;
        ScopeBufX[n]:=x;
        x := x+xstep;
        n++;
    wend
    gfx_Polyline(samples, ScopeBufX, ScopeBufY, colr);  // draw the new sample
endfunc


//===================================================================================
// draw a sinewave
//===================================================================================
func doSineScope(var samples, var colr, var smpl)
    var w,h,n,xstep,yoffs,x,yscale,xoffs,seedoffs;
    w := windowRight-windowLeft;
    h := windowBottom-windowTop;
    xstep:=w/samples+1;
    yscale:=h/2;
    yoffs:=h/2+windowTop;
    x:=windowLeft;
    gfx_Polyline(samples, ScopeBufX, ScopeBufY, BLACK);  // undraw the old buffer first
    while (n<samples)
        ScopeBufY[n]:=SIN(xoffs)/4+yoffs;
        ScopeBufX[n]:=x;
        x := x+xstep;
        xoffs := xoffs+smpl;
        n++;
    wend
    gfx_Polyline(samples, ScopeBufX, ScopeBufY, colr);  // draw the new sample
endfunc

//===================================================================================
// build a polygon with a number of sides determined by var "sides"
// around the current origin. The distance from the origin to the
// equidistent vertices from origin determined
// by var "distance". var "angle" is the starting angle for the
// first virtices. Draws the polygon in colour var "colr"
// NB make sure the array is big enough for the required number of sides
//===================================================================================
func MakePolygon(var angle, var sides, var distance, var colr)
    var index, step;
    index := 0;
    step := 360/sides;                 // work out the step size
    while (sides < 360)                // until we do a complete polygon
        gfx_Orbit(angle, distance);
        Xcoords[index] := targetX;     // build a polygon in the matrix
        Ycoords[index] := targetY;
        index++;
        angle := angle + step;
        sides := sides + step;
    wend
    gfx_Polygon(index, Xcoords, Ycoords, colr);
endfunc

//===================================================================================
// ball object control
//===================================================================================
func DrawBall(var type, var colour)
    var count;

    gosub(type),(
                circle,
                text,
                triangle,
                rectangle,
                pentagon,
                hexagon,
                random
                );
                goto default1;  // unknown type default exit

// case circle
circle:
    gfx_CircleFilled(ball_x, ball_y, BALLSIZE, colour);                 // redraw the ball
    endsub;

// case text
text:
    txt_Opacity(TRANSPARENT);   // transparent text
    txt_FontID(0);              // default small font
    //txt_FGcolour(RAND());
    txt_FGcolour(colour);
    gfx_MoveTo(ball_x, ball_y);    // draw a pixel trail
    putstr("4DGL");
    endsub;


// these cases same, type is used to determine number of sides
triangle:
rectangle:
pentagon:
hexagon:
    gfx_MoveTo(ball_x, ball_y);                 // using the balls origin
    MakePolygon(angle, type, 10, colour);      // make 3 sided polygon = triangle
    endsub;

// case random
random:
    if (colour)
        SEED(newseed);
        gfx_ObjectColour(RAND()|0x8408);    // ensure hi colours
    else
        SEED(newseed++);
        RAND();                     // RAND here to compensate so we get  repeat sequence
        gfx_ObjectColour(BLACK);
    endif

    count := 5;
    while (count--)
        gfx_MoveTo(ball_x+RAND()%15, ball_y+RAND()%15);
        //gfx_Dot();                                        // draw a pixel trail
        gfx_Bullet(3);                                      // draw random circles
        //gfx_BoxTo(ball_x, ball_y);                        // draw random boxes
    wend
    endsub;

default1:

endfunc


//===================================================================================
// part of intro, fill clipped area with pixels then remove in same orded
//===================================================================================
func doDots()
    var n,x,y,w,h;
    // random dots
    SEED(1234);
    w := windowRight - windowLeft;
    h := windowBottom - windowTop;
    n := -3000;
    while (n++<3000)
        x := ABS(RAND()%w) + windowLeft+1;
        y := ABS(RAND()%h) + windowTop+1;
        gfx_PutPixel(x , y , RAND());
    wend

    // undraw the dots
    SEED(1234);
    n := -3000;
    while (n++<3000)
        x := ABS(RAND()%w) + windowLeft+1;
        y := ABS(RAND()%h) + windowTop+1;
        RAND();
        gfx_PutPixel(x , y , 0);
    wend
endfunc

//===================================================================================
// part of intro, fill entire screen with lines then remove in same orded
// Note that clipping will take care of line endpoints outside to clipping area
//===================================================================================
func doLines()
    var n;
    // random lines
    SEED(9876);
    n := -200;
    while (n++<200)
        gfx_Line(ABS(RAND()%screenwidth),ABS(RAND()%screenheight),ABS(RAND()%screenwidth),ABS(RAND()%screenheight),RAND());
    wend

    // undraw the lines
    SEED(9876);
    n := -200;
    while (n++<200)
        gfx_Line(ABS(RAND()%screenwidth),ABS(RAND()%screenheight),ABS(RAND()%screenwidth),ABS(RAND()%screenheight),0);
        RAND();
    wend
endfunc


//===================================================================================
// Check the baal position against the walls.
// Change direction registers accordingly.
//===================================================================================
func collision()

    if(ball_x <= lefthit)
       ball_x := lefthit;
       ball_colour := LEFTCOLOUR;
        xdir := -xdir;
    endif

    if(ball_x >= righthit)
        ball_x := righthit;
        ball_colour := RIGHTCOLOUR;
        xdir := -xdir;
    endif

    if (ball_y <= tophit)
        ball_y := tophit;
        ball_colour := TOPCOLOUR;
        ydir := -ydir;
    endif

    if(ball_y >= bottomhit)
        ball_y := bottomhit;
        ball_colour := BOTTOMCOLOUR;
        ydir := -ydir;
    endif
endfunc



//===================================================================================
//===================================================================================
//===================================================================================
func main()
    var mode, timer, obj, scrollpos, n, linepattern, intro, intronum, scopeloop;


    if (media_Init() == 0)               // initialise and test the uSD card
        print("No uSD CARD Installed\n");
        print("Some demo's are disabled");
        pause(2000);
        gfx_Cls();
    endif




    mode := 0;
    linepattern := 0xF0F0;
    messages[0] := " LANDSCAPE";
    messages[1] := "LANDSCAPE_R";
    messages[2] := " PORTRAIT";
    messages[3] := "PORTRAIT_R";


    //gfx_Set(CONTRAST, 16);
    gfx_Contrast(16);

    gfx_Cls();



    // set generic target variables for the orbit command
    gfx_OrbitInit(&targetX, &targetY);


    txt_Set(FONT_ID, MS_SanSerif8x12);   // dint use default system font, use font provided


repeat

    timer := 0;                         // timer for SCREEN_MODE switching


    gfx_Cls();


    gfx_Set(SCREEN_MODE, mode);         // set required screen mode

    // this is mainly for 'non square' display to make the ball speed realistic
    if (mode < 2)
        xspeed := XSPEED;           // keep correct ball speed aspect
        yspeed := YSPEED;
    else
        xspeed := YSPEED;
        yspeed := XSPEED;


    endif

    // get the display parameters
    screenwidth := peekB(GFX_XMAX);
    screenheight := peekB(GFX_YMAX);

    // determine the centre point
    xc := screenwidth >> 1;
    yc := screenheight >> 1;
                                      
    ball_colour := WHITE;                       // initial ball colour
    xdir := 1; ydir := 1;                       // initial ball direction
    ball_x := 20; ball_y := 20;                 // initial ball position


    // draw the walls
    gfx_RectangleFilled(0, 0, screenwidth-1, WALLWIDTH-1, TOPCOLOUR);                                               // Draw Top Wall
    gfx_RectangleFilled(0, screenheight-WALLWIDTH, screenwidth-1, screenheight-1, BOTTOMCOLOUR);                    // Draw Bottom Wall
    gfx_RectangleFilled(0, WALLWIDTH-1, WALLWIDTH-1, screenheight-WALLWIDTH-1, LEFTCOLOUR);                         // Draw Left Wall
    gfx_RectangleFilled(screenwidth-WALLWIDTH, WALLWIDTH, screenwidth-1, screenheight-WALLWIDTH-1, RIGHTCOLOUR);    // Draw Right Wall



    // calculate the collision positions
    tophit := WALLWIDTH+BALLSIZE;
    bottomhit := screenheight-WALLWIDTH-BALLSIZE-1;
    lefthit := WALLWIDTH+BALLSIZE;
    righthit := screenwidth-WALLWIDTH-BALLSIZE-1;


    // set clipping area
    windowLeft := lefthit;
    windowTop := tophit+10;
    windowRight := righthit - 16;
    windowBottom := bottomhit -40;

    // preset the clipping area, activated later...
    gfx_ClipWindow(windowLeft, windowTop, windowRight, windowBottom);


    // draw a rectangle around the clipped area
    gfx_Rectangle(windowLeft-1, windowTop-1, windowRight+1, windowBottom+1, YELLOW);


    //  test: draw a small outline rectangle outside
    gfx_Rectangle(windowLeft+5, windowBottom+10, windowLeft+15, windowBottom+20, RED);

    // test: draw a small solid rectangle outside
    gfx_RectangleFilled(windowLeft+20, windowBottom+10, windowLeft+30, windowBottom+20, GREEN);

    // test: draw a small outline circle
    gfx_Circle(windowLeft+40, windowBottom+15, 5, BLUE);

    // test: draw a small filled circle
    gfx_CircleFilled(windowLeft+60, windowBottom+15, 5, YELLOW);


    gfx_Set(CLIPPING, OFF);                             // turn off clipping so we can print outside the clip regoin
    txt_FGcolour(RED);
    txt_BGcolour(YELLOW);
    txt_Bold(ON);
    //txt_FontID(2);
    //txt_Set(TEXT_ITALIC, ON);
    //txt_Set(TEXT_OPACITY, TRANSPARENT);               // transparent text is faster
    //gfx_MoveTo(xc-50, yc+20);
    gfx_MoveTo(xc-50, bottomhit -12);
    print(mode," ",[STR] messages[mode]);
    gfx_Set(CLIPPING, ON);                              // turn on clipping


    // decide which intro we use for the next screen
    if (intro)
        intro := 0;
        // clear the clipped area
        gfx_RectangleFilled(windowLeft, windowTop, windowRight, windowBottom, BLACK);
        intronum++;
        if (intronum == 1)
            n:=-180;
            while(n<180)
                doSineScope(SAMPLES, YELLOW, n++);
                n++;
                //pause(10);
            wend
        else if (intronum == 2)
            n:=200;
            while(n)
                doRandScope(SAMPLES, BLUE, n--);
                //pause(10);
            wend
        else if (intronum == 3)
            doLines();
        else
            doDots();
            intronum := 0;
        endif
        gfx_RectangleFilled(windowLeft, windowTop, windowRight, windowBottom, BLACK);
    endif

    // timer0 is the screen mode change timer
    *TIMER0 := 7000;
    repeat

        // draw a cross through the clipped area box
        gfx_LinePattern(linepattern);
        gfx_Line(windowLeft+1, windowTop+1, windowRight-1, windowBottom-1, MAGENTA);
        gfx_Line(windowLeft+1, windowBottom-1, windowRight-1, windowTop+1, MAGENTA);
        gfx_LinePattern(0);

        // timer2 is used for the banner scrolling
        if (!*TIMER2)
            *TIMER2 := 50;
            txt_Opacity(OPAQUE);            // transparent text
            txt_FontID(0);                  // default system font
            gfx_Clipping(OFF);
            gfx_ClipWindow(windowLeft+10,WALLWIDTH,windowRight-10,WALLWIDTH+8);
            gfx_Clipping(ON);
            scrollpos := scrollpos-1;
            n:=strwidth(message);
            if(scrollpos < windowLeft+10-n) scrollpos := windowRight-10;
            gfx_MoveTo(scrollpos, WALLWIDTH+2);
            txt_FGcolour(WHITE);
            txt_BGcolour(DARKGREEN);
            //txt_Italic(ON);
            txt_Bold(ON);
            putstr(message);
            gfx_Clipping(OFF);
            gfx_ClipWindow(windowLeft, windowTop+1, windowRight, windowBottom);
            gfx_Clipping(ON);
        endif


        // timer3 is used to shift the line pattern
        if(!*TIMER3)
            *TIMER3 := 100;
            linepattern := linepattern << 1;
            if (OVF())  linepattern := linepattern | 1;
        endif


        // timer 0 is for ball timing
        if(!*TIMER1)

            *TIMER1 := 30;

            DrawBall(obj, BLACK);                       // erase the ball object

            angle := angle + 10;

            ball_x := ball_x + xdir * xspeed;
            ball_y := ball_y + ydir * yspeed;


            collision();                                // detect collision

            DrawBall(obj, ball_colour);                     // redraw the ball object
            //DrawBall(obj, RAND());                      // redraw the ball object
        endif

    until (!*TIMER0);

    scrollpos := windowLeft+10; // reset the banner

    if (++mode > 3)
        mode := 0;                              // next screen mode
        if (obj++ > HEXAGON) obj:=0;            // nextball object
        intro := 1;                             // set flag so we do the intro
    endif

forever  // start again



endfunc





//=========================================================




